/**
 * Minimal 2D Jacobi example. Code which is commented out demos how to
 * add a PPMWriter for output.
 */
/*
#include <libgeodecomp/io/simpleinitializer.h>
#include <libgeodecomp/io/ppmwriter.h>
#include <libgeodecomp/io/simplecellplotter.h>
#include <libgeodecomp/io/tracingwriter.h>
#include <libgeodecomp/parallelization/serialsimulator.h>
#include <libgeodecomp/parallelization/hiparsimulator.h>
*/
#include <libgeodecomp.h>

using namespace LibGeoDecomp;

class Cell
{
public:
	//template<typename CELL>
    class API :
		public APITraits::HasFixedCoordsOnlyUpdate,
        public APITraits::HasStencil<Stencils::VonNeumann<2, 1> >,
        //public APITraits::HasOpaqueMPIDataType<Cell>,
        public APITraits::HasTorusTopology<2>,	// periodische randbedingung - cube ist konstant
        public APITraits::HasPredefinedMPIDataType<double>
        //public APITraits::SelectMPIDataType< CELL, typename CELL::API::SupportsMPIDataType, typename CELL::API::SupportsAutoGeneratedMPIDataType >,
        //public APITraits::SelectMPIDataType< CELL, typename CELL::API::SupportsMPIDataType, typename CELL::API::SupportsCustomMPIDataType >
    {};

    inline explicit Cell(double v = 0) :
        temp(v)
    {}

    template<typename COORD_MAP>
    void update(const COORD_MAP& neighborhood, const unsigned& nanoStep)
    {
//	int num_vars = 1;
//	for(int i = 0; i < num_vars; ++i){

/*	        temp = (neighborhood[Coord<2>( 0, -1)].temp +
        	        neighborhood[Coord<2>(-1,  0)].temp +
               		neighborhood[Coord<2>( 0,  0)].temp +
                	neighborhood[Coord<2>( 1,  0)].temp +
                	neighborhood[Coord<2>( 0,  1)].temp) * (1.0 / 5.0);

*/
// 		*** 2D5PT ***

		temp = (neighborhood[FixedCoord<-1,  0>()].temp +
			neighborhood[FixedCoord< 0, -1>()].temp +
			neighborhood[FixedCoord< 0,  0>()].temp +
			neighborhood[FixedCoord< 0,  1>()].temp +
			neighborhood[FixedCoord< 1,  0>()].temp) * (1.0 / 5.0);
			
/*		temp = (neighborhood[Coord<2>(-1,  0)].temp +
			neighborhood[Coord<2>( 0, -1)].temp +
			neighborhood[Coord<2>( 0,  0)].temp +
			neighborhood[Coord<2>( 0,  1)].temp +
			neighborhood[Coord<2>( 1,  0)].temp) * (1.0 / 5.0);
*/
/*		temp[i] = (neighborhood[Coord<2>(-1,  0)].temp[i] +
			   neighborhood[Coord<2>( 0, -1)].temp[i] +
			   neighborhood[Coord<2>( 0,  0)].temp[i] +
			   neighborhood[Coord<2>( 0,  1)].temp[i] +
			   neighborhood[Coord<2>( 1,  0)].temp[i]) * (1.0 / 5.0);

*/
// 		*** 2D9PT ***
/*		temp = (neighborhood[Coord<2>(-1, -1)].temp +
			neighborhood[Coord<2>(-1,  0)].temp +
			neighborhood[Coord<2>(-1,  1)].temp +
			
			neighborhood[Coord<2>( 0, -1)].temp +
			neighborhood[Coord<2>( 0,  0)].temp +
			neighborhood[Coord<2>( 0,  1)].temp +
			
			neighborhood[Coord<2>( 1, -1)].temp +
			neighborhood[Coord<2>( 1,  0)].temp +
			neighborhood[Coord<2>( 1,  1)].temp) * (1.0 / 9.0);
*/			
//	}
   }

    double temp;
};

//MPI_Datatype Cell::MPIDataType = MPI_DATATYPE_NULL;

class CellInitializer : public SimpleInitializer<Cell>
{
public:
    CellInitializer(const unsigned dimX, const unsigned dimY, const unsigned num_timesteps) : SimpleInitializer<Cell>(Coord<2>(dimX, dimY), num_timesteps),
    dimX(dimX),
    dimY(dimY)
    {}

    virtual void grid(GridBase<Cell, 2> *ret)
    {
        CoordBox<2> rect = ret->boundingBox();

        for (int y = 0; y < dimY; ++y) {
            for (int x = 0; x < dimX; ++x) {
                Coord<2> c(x, y);
                if (rect.inBounds(c)) {
					// RANDOM_NUMBER max?
                    ret->set(c, Cell(Random::gen_d()));
                    
                    // DEBUG_GRID == 1
                    //ret->set(c, Cell(0.0)); 
                }
            }
        }
    }
private:
	unsigned dimX;
	unsigned dimY;
	unsigned dimZ;
};


class ToleranceChecker : public Clonable<ParallelWriter<Cell>, ToleranceChecker>
{
public:
	typedef ParallelWriter<Cell>::GridType GridType;
	
	ToleranceChecker(const unsigned outputPeriod = 1, unsigned numberOfVars = 1) :
	Clonable<ParallelWriter<Cell>, ToleranceChecker>("", outputPeriod),
	localSum(0),
	globalSum(0),
	num_vars(numberOfVars)
	{
		
	}
	
	void stepFinished(const GridType& grid,
        const RegionType& validRegion,
        const CoordType& globalDimensions,
        unsigned step,
        WriterEvent event,
        std::size_t rank,
        bool lastCall)
    { 
        localSum = 0;  
        globalSum = 0;
        CoordBox<2> box = grid.boundingBox(); 
	
		for(unsigned int j = 0 ; j < num_vars ; ++j ){
        	for (CoordBox<2>::Iterator i = box.begin(); i != box.end(); ++i) { 
        	    localSum += grid.get(*i).temp;
//         	    gridSum += grid.get(*i).temp[j]; 
        	}
		} 

        //gridSum /= box.dimensions.prod(); 
		std::cout << "localSum(" << step << ") = " << localSum << "\n"; 

		MPI_Allreduce(&localSum, &globalSum, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);

		std::cout << "globalSum(" << step << ") = " << globalSum << "\n";
//grids_to_sum kram aus mg_bufinit.f    
//      ERROR_ITER = ABS ( SOURCE_TOTAL(IVAR) - GSUM ) / SOURCE_TOTAL(IVAR)
//      IF ( ERROR_ITER > ERROR_TOL ) THEN

    }
        
private: 
    double localSum;
    double globalSum; 
    unsigned num_vars;
};
/*
class ToleranceChecker : public Clonable<Writer<Cell>, ToleranceChecker> 
{ 
public: 
    typedef Writer<Cell>::GridType GridType; 
 
//    ToleranceChecker(const unsigned outputPeriod, const unsigned num_vars) : 
    ToleranceChecker(const unsigned outputPeriod = 1) : 
       Clonable("", outputPeriod),
       gridSum(0)
//       Clonable<Writer<Cell>, ToleranceChecker>("", outputPeriod), 
//        gridSum(0) 
    {
//		this->num_vars = num_vars;
    } 
	 
    void stepFinished(const GridType& grid, unsigned step, WriterEvent event) 
    { 
		num_vars = 1;
        gridSum = 0;  
        CoordBox<2> box = grid.boundingBox(); 
	
		for(unsigned int j = 0 ; j < num_vars ; ++j ){
        	for (CoordBox<2>::Iterator i = box.begin(); i != box.end(); ++i) { 
        	    gridSum += grid.get(*i).temp;
//         	    gridSum += grid.get(*i).temp[j]; 
        	}
		} 
 
        gridSum /= box.dimensions.prod(); 
		std::cout << "averageTemperature(" << step << ") = " << gridSum << "\n"; 

//grids_to_sum kram aus mg_bufinit.f    
//      ERROR_ITER = ABS ( SOURCE_TOTAL(IVAR) - GSUM ) / SOURCE_TOTAL(IVAR)
//      IF ( ERROR_ITER > ERROR_TOL ) THEN

    } 
 
    double averageTemperature() const 
    { 
        return gridSum; 
    } 
 
private: 
    double gridSum; 
    unsigned num_vars;
}; 

*/

extern "C" void simulate_(int *nx, int *ny, int *nz, int *num_vars, int *num_spikes, int *num_tsteps, double *err_tol)
{
    int argc = 0;
    const char *argv[] = { "dummy" };
	
    MPI_Init(&argc, reinterpret_cast<char***>(&argv));
    
    //printf("mic check 1, 2 from MPI Rank: %i\n", MPILayer().rank());
    
    if (MPILayer().rank() == 0) {
		printf("Dimensions: %i * %i * %i\n", *nx, *ny, *nz);
		printf("Number Of Variables: %i\n", *num_vars);
		printf("Number Of Spikes: %i\n", *num_spikes);
		printf("Number of Timesteps: %i\n", *num_tsteps);
		printf("Error Tolerance: %f\n", *err_tol);
	}
	
    Typemaps::initializeMaps();
	{
		//SerialSimulator<Cell> sim(new CellInitializer(dimX, dimY, num_timesteps));
		CellInitializer *init =  new CellInitializer(*nx, *ny, *num_tsteps);
		
		HiParSimulator::HiParSimulator<Cell, RecursiveBisectionPartition<2> > sim(
				init,
				MPILayer().rank() ? 0 : new TracingBalancer(new NoOpBalancer()),
				*num_tsteps,
				1);

	/*    sim.addWriter(
			new PPMWriter<Cell>(
				&Cell::temp,
				0.0,
				1.0,
				"jacobi",
				outputFrequency,
				Coord<2>(1, 1)));
	*/
	//    sim.addWriter(new TracingWriter<Cell>(outputFrequency, 100));
		if (MPILayer().rank() == 0) {
			printf("I'm rank %i and we're adding Writers\n", MPILayer().rank());
		}
		
		ToleranceChecker *toleranceChecker = new ToleranceChecker(1, *num_vars);
			sim.addWriter(toleranceChecker);
	    /*
	    Writer<Cell> *toleranceChecker = 
			(MPILayer().rank() == 0) ?
			new ToleranceChecker() :
			0;
	    sim.addWriter(new CollectingWriter<Cell>(toleranceChecker, 0, MPI_COMM_WORLD, MPI_DOUBLE));
		*/
		sim.run();
	}
	
    MPI_Finalize();
    
}
